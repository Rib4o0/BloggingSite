function textToBinary(str) {
	return str.split('').map(function (char) {
		return char.charCodeAt(0).toString(2);
	}).join(' ');
}
function binaryToHex(binaryStr) {
	let decimal = parseInt(binaryStr, 2);
	let hex = decimal.toString(16);
	return hex.toLowerCase();
}

function hexToBinary(hex) {
    const binaryString = hex.split('').map(hexChar => {
        return parseInt(hexChar, 16).toString(2).padStart(4, '0');
    }).join('');
    return binaryString;
}

function binaryToDec(bin) {
	let segments = splitSeg(bin, 4);
	let dec = '';
	for (let i = 0; i < segments.length; i++) {
		let sec = (parseInt(segments[segments.length - 1 - i], 2) * (8 ** i)).toString().slice(0, 5)
		sec = sec.replace('.', '');
		dec += sec
	}
	return dec;
}

function binaryToBase64(binaryString) {
	while (binaryString.length % 6 !== 0) {
		binaryString = "0" + binaryString;
	}
	let base64String = "";
	for (let i = 0; i < binaryString.length; i += 6) {
		let chunk = binaryString.substr(i, 6);
		base64String += String.fromCharCode(parseInt(chunk, 2) + 65);
	}
	
	return btoa(base64String);
}

function hexToBase64(hex) {
    const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    const base64String = btoa(String.fromCharCode.apply(null, bytes));
    return base64String;
}

function removeSpaces(str) {
	return str.replace(/\s+/g, '');
}

module.exports = function encrypt(str, encoding = 'hex', compression = false) {
	let bin = removeSpaces(textToBinary(str));
	let paddedBin = pad(bin);
	let segments = split(paddedBin);
	for (let i = 0; i < segments.length; i++) {
		for (let j = i + 1; j < segments.length; j++) {
			let scrambled = scramble(segments[i], segments[j]);
			segments[i] = scrambled.str1;
			segments[j] = scrambled.str2;
		}
	}
	for (let i = 16; i < 64; i++) {
		let segment = ''
		for (let j = 0; j < 32; j++ ) {
			segment += bitwiseAdditionModulo2FourNums(parseInt(rotator1(segments[i - 3])[j]), parseInt(segments[i - 6][j]) ,parseInt(rotator2(segments[i - 13])[j]), parseInt(segments[i - 14][j]))
		}
		segments.push(segment);
	}
	segments = segments.slice(-16);
	let finalBin = segments.join('');
	if (compression) {
		finalBin = '';
		const assemble = "0111010001100101100100101111010001001110001010000000111101011100011101010010101001101001110101000101000101001111011010001011010100111010010101101110100111011101011010100101111001110000010100010011100000010011011101001011101000101110100010100111010100111010011101000110010110010010111101000100111011101000000011110101110001110101001010100110100111010100010100010100111101101000101101010011101001010110111010011101110101101010010111100111000001010001001110000001001101110100101110100010111010001010011101010011101001110100011001011001001011110100010011101110100000000000010111000111010100101010011010011101010001010001010011110110100010110101001110100101011011101001110111010110101001011110011100000101000100111000000100110111010010111010001011101000101001110101001110100111010001100101100100101111010001001110111010000000111101011100011101010010101001101001110101000101000101001111011010001011010100111010010101101110100111011101011010100101111001110000010100010011100000010011011101001011101000101110100010100111010100111010";
		for (let i = 0; i < segments.length; i++) {
			for (let j = 0; j < 32; j++) {
				if (assemble[j + i * 32] === '1') {
					finalBin += segments[i][j];
				}
			}
		}
	}
	
	let finBinSeg = split(finalBin);
	let hash = '';
	if (encoding === 'hex') {
		let smallerSegments = splitSeg(finalBin, 4);
		for (let i = 0; i < smallerSegments.length; i++) {
			hash += binaryToHex(smallerSegments[i]);
		}
	} else if (encoding === 'base64') {
		hash += binaryToBase64(finBinSeg.join(''));
	} else if (encoding === 'binary' || encoding === 'bin') {
		hash = finBinSeg.join('');
	} else if (encoding === 'decimal' || encoding === 'dec') {
		hash = binaryToDec(finalBin);
	} else {
		return "INVALID_ENCODING";
	}
	return hash;
}

function pad(str) {
	let newStr = str + '1';
	let l = str.length;
	let binL = l.toString(2);
	const rand1 = "10100010110101111100100101110111";
	for (let i = binL.length; i < 64; i++) {
		binL = rand1[i % 32] + binL;
	}
	let k = 448 % 512 - 1 - l;
	const rand2 = "10010110011101001001100011001010";
	for (let i = 0; i < k; i++) {
		newStr += rand2[i % 32];
	}
	return newStr + binL;
}

function split(str) {
	let segments = [];
	for (let i = 0; i < str.length; i += 32) {
		segments.push(str.slice(i, i + 32));
	}
	return segments;
}

function splitSeg(str , segmentLenght) {
	let segments = [];
	for (let i = 0; i < str.length; i += segmentLenght) {
		segments.push(str.slice(i, i + segmentLenght));
	}
	return segments;
}

function rotateRight(str, amount) {
	let lastChars = str.slice(-amount);
	str = str.slice(0, -amount);
	return lastChars + str;
}

function scramble(str1, str2) {
	const scrambler = '1110110000000001101111101000001110101111010000110001000100010010110011010110010101010010111010101100000111011001110011110000111000001001001001010001001010001001001010111001101111001011110001100001011001110010010101110101001010000110001000001100001111110111011100011001101001000001111110001110011011110100001010010010011011011000011000100011110110010101010000110000001000100101100101101001100001111111011110001110110011011100010000100010010100011010101111110100100100100010000000110101011101000110000101100010000111101100000000011011111010000011101011110100001100010001000100101100110101100101010100101110101011000001110110011100111100001110000010010010010100010010100010010010101110011011110010111100011000010110011100100101011101010010100001100010000011000011111101110111000110011010010000011111100011100110111101000010100100100110110110000110001000111101100101010100001100000010001001011001011010011000011111110111100011101100110111000100001000100101000110101011111101001001001000100000001101010111010001100001011000100001';
	let str1Arr = str1.split('');
	let str2Arr = str2.split('')
	for (let i = 0; i < str1Arr.length; i++) {
		for (let j = 0; j < str2Arr.length; j++) {
			if (scrambler[str2Arr.length * i + j] === '1') {
				let temp = str1Arr[i];
				str1Arr[i] = str2Arr[j];
				str2Arr[j] = temp;
			}
		}
	}
	let newStr1 = str1Arr.join('');
	let newStr2 = str2Arr.join('');
	return {str1: newStr1, str2: newStr2};
}

function rotator1(str) {
	let rot5 = rotateRight(str.toString(), 5);
	let rot19 = rotateRight(str.toString(), 19);
	let shift7 = shiftRight(str.toString(),7);
	let sigma = '';
	for (let i = 0; i < 32; i++) {
		sigma += bitwiseAdditionModulo2ThreeNums(parseInt(rot5[i]), parseInt(rot19[i]), parseInt(shift7[i]));
	}
	return sigma;
}

function rotator2(str) {
	let rot2 = rotateRight(str.toString(), 2);
	let rot21 = rotateRight(str.toString(), 21);
	let shift3 = shiftRight(str.toString(),3);
	let sigma = '';
	for (let i = 0; i < 32; i++) {
		sigma += bitwiseAdditionModulo2ThreeNums(parseInt(rot2[i]), parseInt(rot21[i]), parseInt(shift3[i]));
	}
	return sigma;
}

function shiftRight(str, amount) {
	str = str.slice(0, -amount);
	for (let i = 0; i < amount; i++) {
		str = "0" + str;
	}
	return str;
}

function bitwiseAdditionModulo2ThreeNums(a, b, c) {
	return a ^ b ^ c;
}

function bitwiseAdditionModulo2FourNums(a, b, c, d) {
	return a ^ b ^ c ^ d;
}
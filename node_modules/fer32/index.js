function textToBinary(str) {
	return str.split('').map(function (char) {
		return char.charCodeAt(0).toString(2);
	}).join(' ');
}

function binaryToHex(binaryStr) {
	let decimal = parseInt(binaryStr, 2);
	let hex = decimal.toString(16);
	return hex.toLowerCase();
}

function binaryToBase64(binaryString) {
	while (binaryString.length % 6 !== 0) {
		binaryString = "0" + binaryString;
	}
	let base64String = "";
	for (let i = 0; i < binaryString.length; i += 6) {
		let chunk = binaryString.substr(i, 6);
		base64String += String.fromCharCode(parseInt(chunk, 2) + 65);
	}
	
	return btoa(base64String);
}

function removeSpaces(str) {
	return str.replace(/\s+/g, '');
}

module.exports = function encrypt(str, encoding = 'hex') {
	let bin = removeSpaces(textToBinary(str));
	let paddedBin = pad(bin);
	let segments = split(paddedBin);
	for (let i = 0; i < segments.length; i++) {
		for (let j = i + 1; j < segments.length; j++) {
			let scrambled = scramble(segments[i], segments[j]);
			segments[i] = scrambled.str1;
			segments[j] = scrambled.str2;
		}
	}
	for (let i = 16; i < 64; i++) {
		let segment = ''
		for (let j = 0; j < 32; j++ ) {
			segment += bitwiseAdditionModulo2FourNums(parseInt(rotator1(segments[i - 3])[j]), parseInt(segments[i - 6][j]) ,parseInt(rotator2(segments[i - 13])[j]), parseInt(segments[i - 14][j]))
		}
		segments.push(segment);
	}
	segments = segments.slice(-16);
	/*let temp = segments[0];
	segments[0] = segments[8];
	segments[8] = segments[10];
	segments[10] = segments[7];
	segments[7] = segments[3];
	segments[3] = temp;
	temp = segments[1];
	segments[1] = segments[2];
	segments[2] = segments[9];
	segments[9] = segments[12];
	segments[12] = segments[13];
	segments[13] = segments[4];
	segments[4] = segments[15];
	segments[15] = segments[11];
	segments[11] = segments[14];
	segments[14] = segments[5];
	segments[5] = segments[6];
	segments[6] = temp;
	for (let i = 0; i < segments.length; i++) {
		for (let j = i + 1; j < segments.length; j++) {
			let scrambled = scramble(segments[i], segments[j]);
			segments[i] = scrambled.str1;
			segments[j] = scrambled.str2;
		}
	}*/
	let hash = '';
	if (encoding === 'hex') {
		for (let i = 0; i < segments.length; i++) {
			hash += binaryToHex(segments[i]);
		}
	} else if (encoding === 'base64') {
		hash += binaryToBase64(segments.join(''));
	} else if (encoding === 'binary') {
		hash = segments.join('');
	} else {
		return "INVALID_ENCODING";
	}
	return hash;
}

function pad(str) {
	let newStr = str + '1';
	let l = str.length;
	let binL = l.toString(2);
	const rand1 = "10100010110101111100100101110111";
	for (let i = binL.length; i < 64; i++) {
		binL = rand1[i % 32] + binL;
	}
	let k = 448 % 512 - 1 - l;
	const rand2 = "10010110011101001001100011001010";
	for (let i = 0; i < k; i++) {
		newStr += rand2[i % 32];
	}
	return newStr + binL;
}

function split(str) {
	let segments = [];
	for (let i = 0; i < str.length; i += 32) {
		segments.push(str.slice(i, i + 32));
	}
	return segments;
}

function rotateRight(str, amount) {
	let lastChars = str.slice(-amount);
	str = str.slice(0, -amount);
	return lastChars + str;
}

function scramble(str1, str2) {
	const scrambler = '1110110000000001101111101000001110101111010000110001000100010010110011010110010101010010111010101100000111011001110011110000111000001001001001010001001010001001001010111001101111001011110001100001011001110010010101110101001010000110001000001100001111110111011100011001101001000001111110001110011011110100001010010010011011011000011000100011110110010101010000110000001000100101100101101001100001111111011110001110110011011100010000100010010100011010101111110100100100100010000000110101011101000110000101100010000111101100000000011011111010000011101011110100001100010001000100101100110101100101010100101110101011000001110110011100111100001110000010010010010100010010100010010010101110011011110010111100011000010110011100100101011101010010100001100010000011000011111101110111000110011010010000011111100011100110111101000010100100100110110110000110001000111101100101010100001100000010001001011001011010011000011111110111100011101100110111000100001000100101000110101011111101001001001000100000001101010111010001100001011000100001';
	let str1Arr = str1.split('');
	let str2Arr = str2.split('')
	for (let i = 0; i < str1Arr.length; i++) {
		for (let j = 0; j < str2Arr.length; j++) {
			if (scrambler[j * i + j] === '1') {
				let temp = str1Arr[i];
				str1Arr[i] = str2Arr[j];
				str2Arr[j] = temp;
			}
		}
	}
	let newStr1 = str1Arr.join('');
	let newStr2 = str2Arr.join('');
	return {str1: newStr1, str2: newStr2};
}

function rotator1(str) {
	let rot5 = rotateRight(str.toString(), 5);
	let rot19 = rotateRight(str.toString(), 19);
	let shift7 = shiftRight(str.toString(),7);
	let sigma = '';
	for (let i = 0; i < 32; i++) {
		sigma += bitwiseAdditionModulo2ThreeNums(parseInt(rot5[i]), parseInt(rot19[i]), parseInt(shift7[i]));
	}
	return sigma;
}

function rotator2(str) {
	let rot2 = rotateRight(str.toString(), 2);
	let rot21 = rotateRight(str.toString(), 21);
	let shift3 = shiftRight(str.toString(),3);
	let sigma = '';
	for (let i = 0; i < 32; i++) {
		sigma += bitwiseAdditionModulo2ThreeNums(parseInt(rot2[i]), parseInt(rot21[i]), parseInt(shift3[i]));
	}
	return sigma;
}

function shiftRight(str, amount) {
	str = str.slice(0, -amount);
	for (let i = 0; i < amount; i++) {
		str = "0" + str;
	}
	return str;
}

function bitwiseAdditionModulo2ThreeNums(a, b, c) {
	return a ^ b ^ c;
}

function bitwiseAdditionModulo2FourNums(a, b, c, d) {
	return a ^ b ^ c ^ d;
}

console.log('rotating')
console.log(rotateRight('rotating', 3))
console.log(Math.sqrt(4157))

const magicNumber = "6447480127925948";

const inputField = document.querySelector('.inputField');
const encoding = document.querySelector('.encoding');
const output = document.querySelector('.output');

var currentEncoding = "hex";

encoding.addEventListener('input', (e) => {
	currentEncoding = e.target.value;
})

inputField.addEventListener('input', (e) => {
	output.textContent = encrypt(e.target.value, currentEncoding);
})
